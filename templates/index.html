<!DOCTYPE html>
<html>

<head>
    <title>Plant Disease Detection</title>
    <link rel="stylesheet" type="text/css" href="{{ url_for('static', filename='styles.css') }}">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <style>
        /* üåà Background and global styles */
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            /* Plant AI Background with blur effect */
            background: url('https://images.unsplash.com/photo-1518531933037-91b2f5f229cc?ixlib=rb-4.0.3&auto=format&fit=crop&w=1950&q=80') no-repeat center center fixed;
            background-size: cover;
            position: relative;
            color: #e0e0e0;
            margin: 0;
            padding: 0;
            min-height: 100vh;
        }

        /* Blur overlay for the background */
        body::before {
            content: "";
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            backdrop-filter: blur(8px);
            background-color: rgba(0, 0, 0, 0.7);
            z-index: -1;
        }

        .container {
            max-width: 1280px;
            margin: 20px auto;
            padding: 0 15px 40px;
        }

        header h1 {
            text-align: center;
            font-weight: 700;
            margin-bottom: 25px;
            color: #f5f5f5;
            letter-spacing: 1px;
            text-shadow: 1px 1px 3px rgba(0, 0, 0, 0.8);
            animation: fadeInDown 1.2s ease-out;
        }

        main {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: 20px;
        }

        /* üé• Video feed container */
        .video-feed-container {
            position: relative;
            width: 100%;
            max-width: 640px;
            box-shadow: 0 4px 15px rgba(255, 255, 255, 0.2);
            border-radius: 10px;
            background: rgba(26, 26, 26, 0.6);
            overflow: hidden;
            animation: fadeIn 1s ease-out;
            transition: transform 0.3s ease-out, box-shadow 0.3s ease-out;
        }

        .video-feed-container:hover {
            transform: translateY(-5px);
            box-shadow: 0 10px 25px rgba(255, 255, 255, 0.3);
        }

        .video-feed {
            width: 100%;
            border-bottom: 1px solid #333;
            overflow: hidden;
        }

        .video-feed img {
            width: 100%;
            display: block;
            border-radius: 10px 10px 0 0;
            background: #000;
        }

        .video-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            justify-content: center;
            align-items: center;
            background-color: rgba(0, 0, 0, 0.75);
            color: #fff;
            font-size: 1.1rem;
            font-weight: 600;
            z-index: 100;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.3s ease;
            border-radius: 10px 10px 0 0;
            text-align: center;
            padding: 20px;
        }

        .video-overlay.visible {
            opacity: 1;
            pointer-events: all;
        }

        .camera-controls {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 12px 15px;
            background: rgba(46, 46, 46, 0.8);
            border-radius: 0 0 10px 10px;
            box-shadow: inset 0 1px 0 #444;
        }

        .status-indicator {
            display: inline-block;
            width: 14px;
            height: 14px;
            border-radius: 50%;
            margin-right: 8px;
            vertical-align: middle;
            box-shadow: 0 0 4px rgba(255, 255, 255, 0.15);
        }

        .status-online {
            background-color: #4CAF50;
            box-shadow: 0 0 8px #4CAF50;
        }

        .status-offline {
            background-color: #F44336;
            box-shadow: 0 0 8px #F44336;
        }

        .reconnect-btn {
            padding: 8px 18px;
            background-color: rgba(85, 85, 85, 0.8);
            color: #f0f0f0;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-weight: 600;
            transition: all 0.25s ease;
            box-shadow: 0 2px 8px rgba(255, 255, 255, 0.2);
        }

        .reconnect-btn:hover {
            background-color: #777;
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(255, 255, 255, 0.3);
        }

        /* üì¶ Cards container */
        .card-container {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 20px;
            justify-items: center;
            width: 100%;
            max-width: 1200px;
            margin-top: 20px;
        }

        /* üé® Card styles with new gradients and animations */
        .card {
            background: linear-gradient(135deg, #1e3c72 0%, #ffffff 50%, #d31027 100%);
            padding: 20px 25px;
            border-radius: 15px;
            box-shadow: 0 4px 15px rgba(255, 255, 255, 0.1);
            width: 90%;
            transition: all 0.5s ease;
            animation: fadeInUp 0.8s ease-out;
            animation-fill-mode: both;
            position: relative;
            overflow: hidden;
        }

        /* Animated gradient border effect */
        .card::before {
            content: '';
            position: absolute;
            top: -2px;
            left: -2px;
            right: -2px;
            bottom: -2px;
            background: linear-gradient(45deg, #ff0000, #0000ff, #ffffff, #ff0000);
            background-size: 400% 400%;
            border-radius: 17px;
            z-index: -1;
            animation: gradientBorder 6s ease infinite;
            opacity: 0;
            transition: opacity 0.3s ease;
        }

        .card:hover::before {
            opacity: 1;
        }

        .card:hover {
            transform: translateY(-8px) scale(1.02);
            box-shadow: 0 15px 30px rgba(30, 60, 114, 0.4);
        }

        .card h2 {
            margin-top: 0;
            font-size: 1.25rem;
            font-weight: 700;
            color: #ffffff;
            margin-bottom: 12px;
            border-bottom: 2px solid rgba(255, 255, 255, 0.3);
            padding-bottom: 6px;
            text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.7);
        }

        .card p {
            font-size: 1rem;
            line-height: 1.5;
            color: #fff;
            margin: 0;
            min-height: 42px;
            font-weight: 500;
            text-shadow: 1px 1px 1px rgba(0, 0, 0, 0.5);
        }

        /* üå§ Forecast scroll inside card */
        .forecast-scroll {
            display: flex;
            overflow-x: auto;
            gap: 12px;
            padding-top: 8px;
            padding-bottom: 6px;
        }

        .forecast-item {
            flex: 0 0 auto;
            text-align: center;
            padding: 12px 10px;
            background-color: rgba(255, 255, 255, 0.2);
            border-radius: 12px;
            box-shadow: inset 0 0 5px rgba(255, 255, 255, 0.1);
            min-width: 70px;
            font-weight: 600;
            color: #f5f5f5;
            user-select: none;
            transition: transform 0.3s ease, background-color 0.3s ease;
        }

        .forecast-item:hover {
            transform: translateY(-3px);
            background-color: rgba(255, 255, 255, 0.3);
        }

        .forecast-item .hour {
            font-size: 0.85rem;
            margin-bottom: 6px;
            color: #fff;
        }

        .forecast-item img {
            width: 48px;
            height: 48px;
            margin-bottom: 6px;
            filter: drop-shadow(0 0 2px rgba(255, 255, 255, 0.2));
            transition: transform 0.3s ease;
        }

        .forecast-item:hover img {
            transform: scale(1.1);
        }

        .forecast-item .temp {
            font-size: 0.9rem;
            color: #fff;
            font-weight: 700;
        }

        /* Sensor data table styles */
        table {
            width: 100%;
            border-collapse: collapse;
            margin-bottom: 20px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 10px;
            overflow: hidden;
            animation: fadeIn 1s ease-out;
        }

        th,
        td {
            padding: 12px 15px;
            text-align: left;
            border-bottom: 1px solid #444;
        }

        th {
            background-color: rgba(0, 0, 0, 0.5);
            color: #f0f0f0;
            font-weight: 600;
        }

        tr:last-child td {
            border-bottom: none;
        }

        /* Live sensor data display */
        .sensor-data-display {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 15px;
            margin-top: 10px;
            animation: fadeIn 1s ease-out;
        }

        .sensor-item {
            background: rgba(0, 0, 0, 0.6);
            padding: 12px 15px;
            border-radius: 8px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            transition: transform 0.3s ease, background 0.3s ease;
            border-left: 3px solid transparent;
        }

        .sensor-item:hover {
            transform: translateX(5px);
            background: rgba(30, 60, 114, 0.6);
            border-left: 3px solid #4CAF50;
        }

        .sensor-label {
            font-weight: 600;
            color: #ddd;
        }

        .sensor-value {
            font-weight: 700;
            color: #fff;
            font-size: 1.1rem;
        }

        .update-status {
            grid-column: span 2;
            text-align: center;
            margin-top: 10px;
            font-size: 0.85rem;
            color: #aaa;
        }

        .chart-controls {
            display: flex;
            justify-content: space-between;
            margin-bottom: 15px;
        }

        .chart-btn {
            padding: 8px 16px;
            background: linear-gradient(to right, #1e3c72, #2a5298);
            color: #fff;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-weight: 600;
            transition: all 0.3s ease;
        }

        .chart-btn:hover {
            background: linear-gradient(to right, #2a5298, #1e3c72);
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(42, 82, 152, 0.4);
        }

        .chart-select {
            padding: 8px 16px;
            background: rgba(51, 51, 51, 0.8);
            color: #fff;
            border: 1px solid #555;
            border-radius: 5px;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .chart-select:hover {
            background: rgba(70, 70, 70, 0.8);
            border-color: #777;
        }

        /* Sensor history card */
        .sensor-history-card {
            width: 100%;
            max-height: 400px;
            overflow-y: auto;
            padding-right: 5px;
            /* Scrollbar styling */
            scrollbar-width: thin;
            scrollbar-color: #555 #222;
        }

        .sensor-history-card::-webkit-scrollbar {
            width: 8px;
        }

        .sensor-history-card::-webkit-scrollbar-track {
            background: #222;
            border-radius: 4px;
        }

        .sensor-history-card::-webkit-scrollbar-thumb {
            background-color: #555;
            border-radius: 4px;
        }

        .history-item {
            background: rgba(0, 0, 0, 0.4);
            margin-bottom: 10px;
            padding: 12px;
            border-radius: 8px;
            border-left: 3px solid #4CAF50;
            transition: all 0.3s ease;
            animation: fadeInRight 0.5s ease-out;
        }

        .history-item:hover {
            transform: translateX(5px);
            background: rgba(0, 0, 0, 0.6);
            border-left: 3px solid #2196F3;
        }

        .history-timestamp {
            font-size: 0.85rem;
            color: #aaa;
            margin-bottom: 5px;
        }

        .history-data {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 10px;
        }

        .history-value {
            display: flex;
            justify-content: space-between;
        }

        .history-label {
            color: #ccc;
        }

        .history-number {
            font-weight: 700;
            color: #fff;
        }

        /* Relay control styles */
        .relay-controls {
            background: linear-gradient(135deg, #1e3c72 0%, #2a5298 100%);
            padding: 15px;
            border-radius: 10px;
            margin: 20px 0;
            box-shadow: 0 4px 15px rgba(255, 255, 255, 0.1);
            width: 100%;
            max-width: 640px;
            animation: fadeInUp 0.8s ease-out;
            transition: transform 0.3s ease, box-shadow 0.3s ease;
        }

        .relay-controls:hover {
            transform: translateY(-5px);
            box-shadow: 0 10px 25px rgba(42, 82, 152, 0.4);
        }

        .relay-header {
            font-size: 1.1rem;
            font-weight: 700;
            margin-bottom: 10px;
            color: #f0f0f0;
            border-bottom: 2px solid rgba(255, 255, 255, 0.3);
            padding-bottom: 6px;
        }

        .relay-buttons {
            display: flex;
            justify-content: space-between;
            margin-bottom: 15px;
        }

        .relay-timer {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 10px;
            margin-top: 15px;
        }

        .active-mode {
            background-color: #4CAF50 !important;
            color: white !important;
            box-shadow: 0 0 10px rgba(76, 175, 80, 0.7) !important;
            animation: pulse 1.5s infinite;
        }

        .timer-active {
            background-color: #2196F3 !important;
            color: white !important;
            box-shadow: 0 0 10px rgba(33, 150, 243, 0.7) !important;
            animation: pulse 1.5s infinite;
        }

        .relay-status {
            margin-top: 15px;
            text-align: center;
            font-size: 0.9rem;
            color: #fff;
            padding: 8px;
            background-color: rgba(0, 0, 0, 0.3);
            border-radius: 5px;
            transition: all 0.3s ease;
        }

        /* New styles for soil moisture DRY/WET indicator */
        .sensor-value .dry {
            color: #ff6b6b !important;
            animation: blink 2s infinite;
        }

        .sensor-value .wet {
            color: #4ecdc4 !important;
        }

        /* When timer is counting down, add a blinking effect */
        @keyframes timer-countdown {
            0% {
                opacity: 1;
            }

            50% {
                opacity: 0.6;
            }

            100% {
                opacity: 1;
            }
        }

        .timer-countdown {
            animation: timer-countdown 1s infinite;
        }

        /* New animations */
        @keyframes fadeIn {
            from {
                opacity: 0;
            }

            to {
                opacity: 1;
            }
        }

        @keyframes fadeInUp {
            from {
                opacity: 0;
                transform: translateY(20px);
            }

            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        @keyframes fadeInDown {
            from {
                opacity: 0;
                transform: translateY(-20px);
            }

            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        @keyframes fadeInRight {
            from {
                opacity: 0;
                transform: translateX(-20px);
            }

            to {
                opacity: 1;
                transform: translateX(0);
            }
        }

        @keyframes pulse {
            0% {
                transform: scale(1);
            }

            50% {
                transform: scale(1.05);
            }

            100% {
                transform: scale(1);
            }
        }

        @keyframes blink {
            0% {
                opacity: 1;
            }

            50% {
                opacity: 0.6;
            }

            100% {
                opacity: 1;
            }
        }

        @keyframes gradientBorder {
            0% {
                background-position: 0% 50%;
            }

            50% {
                background-position: 100% 50%;
            }

            100% {
                background-position: 0% 50%;
            }
        }

        /* Add staggered animation delays to cards */
        .card-container .card:nth-child(1) {
            animation-delay: 0.1s;
        }

        .card-container .card:nth-child(2) {
            animation-delay: 0.2s;
        }

        .card-container .card:nth-child(3) {
            animation-delay: 0.3s;
        }

        .card-container .card:nth-child(4) {
            animation-delay: 0.4s;
        }

        .card-container .card:nth-child(5) {
            animation-delay: 0.5s;
        }

        .card-container .card:nth-child(6) {
            animation-delay: 0.6s;
        }

        .card-container .card:nth-child(7) {
            animation-delay: 0.7s;
        }

        /* üì± Responsive tweaks */
        @media (max-width: 720px) {
            .card-container {
                grid-template-columns: 1fr;
            }

            .card {
                width: 100%;
            }
        }

        @media (max-width: 600px) {
            .sensor-data-display {
                grid-template-columns: 1fr;
            }

            .update-status {
                grid-column: span 1;
            }
        }

        /* Add animation for value changes */
        .value-changed {
            animation: highlight 1.5s ease-out;
        }

        @keyframes highlight {
            0% {
                background-color: rgba(76, 175, 80, 0.5);
            }

            100% {
                background-color: transparent;
            }
        }
    </style>
</head>

<body>
    <div class="container">
        <header>
            <h1>Plant Disease Detection</h1>
        </header>

        <!-- Updated Irrigation Control HTML Section -->
        <div class="relay-controls">
            <div class="relay-header">üö∞ Irrigation Control</div>

            <div class="relay-buttons">
                <button id="btnAutomatic" class="reconnect-btn">Automatic</button>
                <button id="btnManual" class="reconnect-btn">Manual</button>
            </div>

            <div class="relay-timer">
                <span>Timer (seconds):</span>
                <button id="timerMinus" class="reconnect-btn">-</button>
                <span id="timerValue" style="min-width: 30px; text-align: center; font-weight: bold;">0</span>
                <button id="timerPlus" class="reconnect-btn">+</button>
                <button id="btnTimer" class="reconnect-btn">Set Timer</button>
            </div>

            <div class="relay-status" id="relayStatus">
                Loading relay status...
            </div>
        </div>

        <h2>üå± Live Sensor Data</h2>
        <div id="live-sensor-data" class="sensor-data-display">
            <div class="sensor-item">
                <span class="sensor-label">Temperature:</span>
                <span id="live-temp" class="sensor-value">{{ current.Temperature }}¬∞C</span>
            </div>
            <div class="sensor-item">
                <span class="sensor-label">Humidity:</span>
                <span id="live-humidity" class="sensor-value">{{ current.Humidity }}%</span>
            </div>
            <div class="sensor-item">
                <span class="sensor-label">Soil Moisture:</span>
                <span id="live-soil" class="sensor-value">
                    {% if current.Soil == "1" or current.Soil == 1 %}
                    <span class="dry">DRY</span>
                    {% elif current.Soil == "0" or current.Soil == 0 %}
                    <span class="wet">WET</span>
                    {% else %}
                    {{ current.Soil }}%
                    {% endif %}
                </span>
            </div>
            <div class="sensor-item">
                <span class="sensor-label">Water Level:</span>
                <span id="live-water" class="sensor-value">
                    {% if current.Water %}
                    {{ (current.Water|int / 10)|int }}%
                    {% else %}
                    0%
                    {% endif %}
                </span>
            </div>
            <div class="update-status">
                <span id="last-update-time">Last updated: Just now</span>
            </div>
        </div>


        <div class="card" style="max-height: 400px; overflow-y: auto; padding: 10px;">
            <h2 style="margin-bottom: 10px;">üìä Sensor History</h2>

            <div class="chart-controls" style="display: flex; justify-content: space-between; margin-bottom: 10px;">
                <button id="refresh-chart" class="chart-btn">Refresh Data</button>
                <select id="chart-type" class="chart-select">
                    <option value="bar">Bar Chart</option>
                    <option value="line">Line Chart</option>
                </select>
            </div>

            <div style="height: 300px; overflow-x: auto;">
                <canvas id="sensorChart" style="box-sizing: border-box; display: block; height: 300px; width: 1000px;"
                    width="1000" height="375">
                </canvas>
            </div>

        </div>


        <div class="card">
            <h2>üìù Sensor History Data</h2>
            <div id="sensor-history" class="sensor-history-card">
                <!-- History items will be added here dynamically -->
                <div class="history-loading">Loading history data...</div>
            </div>
        </div>

        <main>
            <div class="video-feed-container">
                <div class="video-feed">
                    <img id="videoFeed" src="{{ url_for('video_feed') }}" alt="Video Feed">
                </div>
                <div id="videoOverlay" class="video-overlay">
                    <p>Camera disconnected. Click reconnect to try again.</p>
                </div>
                <div class="camera-controls">
                    <div>
                        <span class="status-indicator status-offline" id="cameraStatus"></span>
                        <span id="cameraStatusText">Checking camera...</span>
                    </div>
                    <button class="reconnect-btn" id="reconnectBtn">Reconnect Camera</button>
                </div>
            </div>




            <div class="card-container">
                <div class="card">
                    <h2>Detected Disease</h2>
                    <p id="disease">No disease detected</p>
                </div>
                <div class="card">
                    <h2>Pesticide Recommendation</h2>
                    <p id="pesticide">-</p>
                </div>
                <div class="card">
                    <h2>Precautionary Advice</h2>
                    <p id="precaution">-</p>
                </div>
                <div class="card">
                    <h2>Crop Suggestion</h2>
                    <p id="cropSuggestion">-</p>
                </div>
                <div class="card">
                    <h2>Geographical Location</h2>
                    <p id="location">Fetching location...</p>
                </div>
                <div class="card">
                    <h2>Climate Data</h2>
                    <p id="climate">Fetching climate data...</p>
                </div>
                <div class="card forecast-card">
                    <h2>Today Forecast</h2>
                    <div class="forecast-scroll" id="forecastScroll">
                        <p>Loading forecast...</p>
                    </div>
                </div>
            </div>
        </main>
    </div>

    <!-- Chart.js CDN - Fixed script tag -->
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>

    <script>
        // Elements
        const diseaseElement = document.getElementById('disease');
        const pesticideElement = document.getElementById('pesticide');
        const precautionElement = document.getElementById('precaution');
        const cropSuggestionElement = document.getElementById('cropSuggestion');
        const locationElement = document.getElementById('location');
        const climateElement = document.getElementById('climate');
        const videoFeedElement = document.getElementById('videoFeed');
        const videoOverlay = document.getElementById('videoOverlay');
        const cameraStatusIndicator = document.getElementById('cameraStatus');
        const cameraStatusText = document.getElementById('cameraStatusText');
        const reconnectBtn = document.getElementById('reconnectBtn');
        const sensorHistoryContainer = document.getElementById('sensor-history');

        // Global variable to store Chart instance
        let sensorChart = null;

        // Camera status and reconnection
        let isVideoFeedWorking = true;
        let retryCount = 0;

        // Check camera status
        function checkCameraStatus() {
            fetch('/camera_status')
                .then(response => response.json())
                .then(data => {
                    if (data.connected) {
                        cameraStatusIndicator.className = 'status-indicator status-online';
                        cameraStatusText.textContent = 'Camera connected';
                        videoOverlay.classList.remove('visible');
                    } else {
                        cameraStatusIndicator.className = 'status-indicator status-offline';
                        cameraStatusText.textContent = 'Camera disconnected';
                        videoOverlay.classList.add('visible');
                    }
                })
                .catch(error => {
                    console.error('Error checking camera status:', error);
                    cameraStatusIndicator.className = 'status-indicator status-offline';
                    cameraStatusText.textContent = 'Camera status unknown';
                });
        }

        // Monitor video feed for errors
        videoFeedElement.onerror = function () {
            console.warn('Video feed error detected');
            isVideoFeedWorking = false;
            retryCount++;

            if (retryCount > 3) {
                videoOverlay.classList.add('visible');
                cameraStatusIndicator.className = 'status-indicator status-offline';
                cameraStatusText.textContent = 'Camera disconnected';
            }
        };

        // Video feed loaded successfully
        videoFeedElement.onload = function () {
            console.log('Video feed loaded successfully');
            isVideoFeedWorking = true;
            retryCount = 0;
            videoOverlay.classList.remove('visible');
        };

        // Reconnect camera
        reconnectBtn.addEventListener('click', function () {
            cameraStatusText.textContent = 'Reconnecting...';
            fetch('/reconnect_camera')
                .then(response => response.json())
                .then(data => {
                    if (data.success) {
                        // Reload the video feed
                        const currentSrc = videoFeedElement.src;
                        videoFeedElement.src = '';
                        setTimeout(() => {
                            videoFeedElement.src = currentSrc;
                        }, 1000);

                        cameraStatusIndicator.className = 'status-indicator status-online';
                        cameraStatusText.textContent = 'Camera reconnected';
                        videoOverlay.classList.remove('visible');
                    } else {
                        cameraStatusIndicator.className = 'status-indicator status-offline';
                        cameraStatusText.textContent = 'Reconnection failed';
                        videoOverlay.classList.add('visible');
                    }
                })
                .catch(error => {
                    console.error('Error reconnecting camera:', error);
                    cameraStatusIndicator.className = 'status-indicator status-offline';
                    cameraStatusText.textContent = 'Reconnection error';
                });
        });

        // Disease detection
        function updateDiseaseInfo(disease) {
            if (!disease || disease === '' || disease === 'background') {
                diseaseElement.textContent = 'No disease detected';
                pesticideElement.textContent = '-';
                precautionElement.textContent = '-';
                cropSuggestionElement.textContent = '-';
                return;
            }

            // Helper function to render lists
            function renderList(items) {
                if (!items || items.length === 0) return '-';
                let html = '<ul>';
                items.forEach(item => {
                    html += `<li>${item}</li>`;
                });
                html += '</ul>';
                return html;
            }

            fetch(`/disease_info/${disease}`)
                .then(response => response.json())
                .then(data => {
                    diseaseElement.textContent = disease.charAt(0).toUpperCase() + disease.slice(1);
                    pesticideElement.innerHTML = renderList(data.pesticide);
                    precautionElement.innerHTML = renderList(data.precaution);
                    cropSuggestionElement.innerHTML = renderList(data.crop_suggestion);
                })
                .catch(error => {
                    console.error('Error fetching disease information:', error);
                    pesticideElement.textContent = '-';
                    precautionElement.textContent = '-';
                    cropSuggestionElement.textContent = '-';
                });
        }

        function fetchDetectedDisease() {
            fetch('/detected_disease')
                .then(response => response.json())
                .then(data => {
                    const detectedDisease = data.disease;
                    updateDiseaseInfo(detectedDisease);
                })
                .catch(error => {
                    console.error('Error fetching detected disease:', error);
                })
                .finally(() => {
                    setTimeout(fetchDetectedDisease, 3000);
                });
        }

        // Climate data
        const API_KEY = 'e1d854c0293b3c6adeb8121ded279f44';

        function fetchForecast(lat, lon) {
            const api = API_KEY;
            fetch(`https://api.openweathermap.org/data/2.5/forecast?lat=${lat}&lon=${lon}&units=metric&appid=${api}`)
                .then(res => res.json())
                .then(data => {
                    const forecastContainer = document.getElementById('forecastScroll');
                    forecastContainer.innerHTML = '';
                    if (data && data.list) {
                        const today = new Date().getDate();
                        const todayItems = data.list.filter(item => {
                            return new Date(item.dt_txt).getDate() === today;
                        });

                        if (todayItems.length === 0) {
                            forecastContainer.innerHTML = '<p>No forecast available for today</p>';
                            return;
                        }

                        todayItems.forEach(item => {
                            const time = new Date(item.dt_txt);
                            let hour = time.getHours();
                            let label = '';
                            if (hour === 0) label = '12AM';
                            else if (hour < 12) label = hour + 'AM';
                            else if (hour === 12) label = '12PM';
                            else label = (hour - 12) + 'PM';

                            const temp = Math.round(item.main.temp);
                            const icon = item.weather[0].icon;
                            const weatherDesc = item.weather[0].main;

                            const itemDiv = document.createElement('div');
                            itemDiv.className = 'forecast-item';
                            itemDiv.innerHTML = `
                                <div class="hour">${label}</div>
                                <img src="https://openweathermap.org/img/wn/${icon}@2x.png" alt="${weatherDesc}">
                                <div class="temp">${temp}¬∞C</div>
                            `;
                            forecastContainer.appendChild(itemDiv);
                        });
                    } else {
                        forecastContainer.innerHTML = '<p>Unable to fetch forecast data</p>';
                    }
                })
                .catch(err => {
                    console.error('Forecast API error:', err);
                    document.getElementById('forecastScroll').innerHTML = '<p>Error loading forecast</p>';
                });
        }

        // Get location and weather
        function initGeolocation() {
            if (navigator.geolocation) {
                navigator.geolocation.getCurrentPosition(position => {
                    const lat = position.coords.latitude;
                    const lon = position.coords.longitude;
                    locationElement.textContent = `Lat: ${lat.toFixed(3)}, Lon: ${lon.toFixed(3)}`;

                    // Use our backend endpoint instead of direct API call
                    fetch(`/climate_data?lat=${lat}&lon=${lon}`)
                        .then(response => response.json())
                        .then(data => {
                            if (data && data.main && data.weather) {
                                const temp = data.main.temp;
                                const humidity = data.main.humidity;
                                const weather = data.weather[0].description;
                                climateElement.innerHTML = `
                                    üå°Ô∏è Temp: ${temp}¬∞C | üíß Humidity: ${humidity}% | üå§Ô∏è ${weather.charAt(0).toUpperCase() + weather.slice(1)}
                                `;
                            } else {
                                climateElement.textContent = 'Unable to fetch weather data';
                            }
                        })
                        .catch(err => {
                            console.error('Weather API error:', err);
                            climateElement.textContent = 'Unable to fetch weather data';
                        });

                    // Fetch forecast
                    fetchForecast(lat, lon);

                }, error => {
                    console.error('Geolocation error:', error);
                    locationElement.textContent = 'Location not available';
                    climateElement.textContent = 'Climate data not available';
                });
            } else {
                locationElement.textContent = 'Geolocation not supported';
                climateElement.textContent = 'Climate data not available';
            }
        }

        // Function to load and display sensor history data
        function loadSensorHistory() {
            fetch('/sensor/logs')
                .then(response => response.json())
                .then(data => {
                    if (!data || data.length === 0) {
                        sensorHistoryContainer.innerHTML = '<div class="history-empty">No history data available</div>';
                        return;
                    }

                    sensorHistoryContainer.innerHTML = '';

                    // Sort data by timestamp (newest first)
                    data.sort((a, b) => {
                        return b.timestamp.localeCompare(a.timestamp);
                    });

                    // Add each history item
                    data.forEach(item => {
                        const historyItem = document.createElement('div');
                        historyItem.className = 'history-item';

                        // Format soil value for display
                        let soilDisplay = item.soilMoisture;
                        if (item.soilMoisture === 1 || item.soilMoisture === "1") {
                            soilDisplay = "<span style='color:#ff6b6b'>DRY</span>";
                        } else if (item.soilMoisture === 0 || item.soilMoisture === "0") {
                            soilDisplay = "<span style='color:#4ecdc4'>WET</span>";
                        } else {
                            soilDisplay = `${item.soilMoisture}%`;
                        }

                        // Calculate water percentage
                        const waterPercentage = Math.floor(parseFloat(item.water) / 10);

                        historyItem.innerHTML = `
                            <div class="history-timestamp">ID: ${item.timestamp}</div>
                            <div class="history-data">
                                <div class="history-value">
                                    <span class="history-label">Temperature:</span>
                                    <span class="history-number">${item.temperature}¬∞C</span>
                                </div>
                                <div class="history-value">
                                    <span class="history-label">Humidity:</span>
                                    <span class="history-number">${item.humidity}%</span>
                                </div>
                                <div class="history-value">
                                    <span class="history-label">Soil Moisture:</span>
                                    <span class="history-number">${soilDisplay}</span>
                                </div>
                                <div class="history-value">
                                    <span class="history-label">Water Level:</span>
                                    <span class="history-number">${waterPercentage}%</span>
                                </div>
                            </div>
                        `;

                        sensorHistoryContainer.appendChild(historyItem);
                    });
                })
                .catch(error => {
                    console.error('Error loading sensor history:', error);
                    sensorHistoryContainer.innerHTML = '<div class="history-error">Error loading history data</div>';
                });
        }

        // Function to refresh the sensor chart with new data
        function refreshSensorChart() {
            return fetch('/sensor/logs')
                .then(response => response.json())
                .then(data => {
                    if (sensorChart) {
                        sensorChart.destroy(); // Destroy existing chart
                    }

                    const timestamps = [];
                    const temperatures = [];
                    const humidities = [];
                    const soils = [];
                    const waters = [];

                    for (let i = 0; i < data.length; i++) {
                        const entry = data[i];
                        timestamps.push(entry.timestamp);
                        temperatures.push(entry.temperature);
                        humidities.push(entry.humidity);

                        // Handle soil display for chart (numbers only)
                        if (entry.soilMoisture === "1" || entry.soilMoisture === 1) {
                            soils.push(1); // DRY
                        } else if (entry.soilMoisture === "0" || entry.soilMoisture === 0) {
                            soils.push(0); // WET
                        } else {
                            soils.push(entry.soilMoisture);
                        }

                        // Calculate water percentage for chart
                        waters.push(Math.floor(parseFloat(entry.water) / 10));
                    }

                    const chartType = document.getElementById('chart-type').value || 'bar';
                    const ctx = document.getElementById('sensorChart').getContext('2d');
                    sensorChart = new Chart(ctx, {
                        type: chartType,
                        data: {
                            labels: timestamps,
                            datasets: [
                                {
                                    label: 'Temperature',
                                    data: temperatures,
                                    backgroundColor: 'rgba(255, 99, 132, 0.7)',
                                    borderColor: 'rgba(255, 99, 132, 1)',
                                    borderWidth: 2,
                                    tension: 0.4
                                },
                                {
                                    label: 'Humidity',
                                    data: humidities,
                                    backgroundColor: 'rgba(54, 162, 235, 0.7)',
                                    borderColor: 'rgba(54, 162, 235, 1)',
                                    borderWidth: 2,
                                    tension: 0.4
                                },
                                {
                                    label: 'Soil',
                                    data: soils,
                                    backgroundColor: 'rgba(75, 192, 192, 0.7)',
                                    borderColor: 'rgba(75, 192, 192, 1)',
                                    borderWidth: 2,
                                    tension: 0.4
                                },
                                {
                                    label: 'Water',
                                    data: waters,
                                    backgroundColor: 'rgba(255, 206, 86, 0.7)',
                                    borderColor: 'rgba(255, 206, 86, 1)',
                                    borderWidth: 2,
                                    tension: 0.4
                                }
                            ]
                        },
                        options: {
                            responsive: true,
                            scales: {
                                y: {
                                    beginAtZero: true
                                }
                            }
                        }
                    });
                })
                .catch(error => {
                    console.error('Error fetching sensor logs:', error);
                });
        }

        // Chart type change handler
        document.getElementById('chart-type').addEventListener('change', function () {
            if (sensorChart) {
                sensorChart.config.type = this.value;
                sensorChart.update();
            }
        });

        // Refresh chart button handler
        document.getElementById('refresh-chart').addEventListener('click', function () {
            this.disabled = true;
            this.textContent = 'Refreshing...';

            refreshSensorChart().then(() => {
                this.disabled = false;
                this.textContent = 'Refresh Data';
            });
        });

        // Initialize all components
        function initApp() {
            checkCameraStatus();          // Check camera status initially
            fetchDetectedDisease();       // Start polling for disease detection
            initGeolocation();            // Get location and weather data
            refreshSensorChart();         // Initialize the chart with current data
            loadSensorHistory();          // Load sensor history data

            // Check camera status periodically
            setInterval(checkCameraStatus, 10000);

            // Auto-refresh chart every 5 minutes
            setInterval(() => {
                refreshSensorChart();
                console.log("Auto-refreshed chart");
            }, 300000); // 5 minutes
        }

        // Start the application
        window.onload = initApp;
    </script>

    <!-- Only updating the JavaScript portions related to Timer and Soil Moisture Control -->
    <script>
        // ================ FIREBASE IRRIGATION CONTROL INTEGRATION ================
        // This script ensures proper Firebase integration for the irrigation control system

        // ---- Elements & Global Variables ----
        const liveSoilElement = document.getElementById('live-soil');
        const liveWaterElement = document.getElementById('live-water');
        const btnAutomatic = document.getElementById('btnAutomatic');
        const btnManual = document.getElementById('btnManual');
        const btnTimer = document.getElementById('btnTimer');
        const timerPlus = document.getElementById('timerPlus');
        const timerMinus = document.getElementById('timerMinus');
        const timerValueElement = document.getElementById('timerValue');
        const relayStatusElement = document.getElementById('relayStatus');

        // Tracking states for buttons
        let manualButtonState = false;
        let timerVal = 0;
        let timerActive = false;
        let timerCountdown = null;
        let timerRemainingSeconds = 0;

        // ---- Firebase Utilities ----

        // Update relay button states based on Firebase data
        function updateRelayButtonStates(data) {
            console.log("Updating relay button states with data:", data);

            // Update Manual button status independently
            if (data.Manual === "1") {
                btnManual.classList.add('active-mode');
                manualButtonState = true;
            } else {
                btnManual.classList.remove('active-mode');
                manualButtonState = false;
            }

            // Update Automatic button status independently
            if (data.Automatic === "1") {
                btnAutomatic.classList.add('active-mode');

                // Update status text
                if (data.Timer === "1") {
                    relayStatusElement.textContent = 'Mode: Automatic (Timer)';
                } else {
                    relayStatusElement.textContent = 'Mode: Automatic';
                }
            } else {
                btnAutomatic.classList.remove('active-mode');

                // Only update status text if we're not in manual mode
                if (data.Manual !== "1") {
                    relayStatusElement.textContent = 'Mode: OFF';
                }
            }

            // If Manual is active, update status text for Manual mode
            if (data.Manual === "1") {
                relayStatusElement.textContent = 'Mode: Manual (ON)';
            }

            // Handle timer if present
            if (data.Timer === "1") {
                // Timer is active
                btnTimer.classList.add('timer-active');

                // Check if we have remaining seconds from server
                if (data.TimerRemaining !== undefined) {
                    timerRemainingSeconds = parseInt(data.TimerRemaining);
                } else if (data.TimerDuration) {
                    // Fallback to duration if no remaining time
                    timerRemainingSeconds = parseInt(data.TimerDuration);
                }

                // Update the displayed value
                timerValueElement.textContent = timerRemainingSeconds;
                timerValueElement.classList.add('timer-countdown');

                // Add timer info to status text
                if (!relayStatusElement.textContent.includes('Timer:')) {
                    relayStatusElement.textContent += ` | Timer: ${timerRemainingSeconds}s remaining`;
                } else {
                    // Update existing timer text
                    relayStatusElement.textContent = relayStatusElement.textContent.replace(/Timer:.*/, `Timer: ${timerRemainingSeconds}s remaining`);
                }

                // Start or update client-side countdown
                startTimerCountdown(timerRemainingSeconds);

            } else {
                // Timer is inactive
                btnTimer.classList.remove('timer-active');
                timerValueElement.classList.remove('timer-countdown');

                // If we have a timer duration stored from before, display it
                if (data.TimerDuration) {
                    timerVal = parseInt(data.TimerDuration);
                    timerValueElement.textContent = timerVal;
                }

                // Remove timer info from status text
                if (relayStatusElement.textContent.includes(' | Timer:')) {
                    relayStatusElement.textContent = relayStatusElement.textContent.replace(/ \| Timer:.*/, '');
                }

                // Stop any existing countdown
                if (timerCountdown) {
                    clearInterval(timerCountdown);
                    timerCountdown = null;
                }
            }
        }

        // Start timer countdown function with improved UI feedback
        function startTimerCountdown(seconds) {
            // Clear any existing countdown
            if (timerCountdown) {
                clearInterval(timerCountdown);
            }

            // Set the initial countdown value
            let remainingSeconds = seconds;

            // Update the timer display
            timerValueElement.textContent = remainingSeconds;

            // Start the countdown interval
            timerCountdown = setInterval(() => {
                remainingSeconds--;

                // Update the display
                timerValueElement.textContent = remainingSeconds;

                // Update status text
                if (relayStatusElement.textContent.includes('Timer:')) {
                    relayStatusElement.textContent = relayStatusElement.textContent.replace(/Timer:.*/, `Timer: ${remainingSeconds}s remaining`);
                }

                // Visual feedback - pulse animation gets faster as timer nears end
                if (remainingSeconds <= 5) {
                    timerValueElement.style.animation = "timer-countdown 0.5s infinite";
                } else if (remainingSeconds <= 10) {
                    timerValueElement.style.animation = "timer-countdown 0.8s infinite";
                }

                // When timer reaches zero
                if (remainingSeconds <= 0) {
                    // Clear the interval
                    clearInterval(timerCountdown);
                    timerCountdown = null;

                    // Reset visual effects
                    timerValueElement.classList.remove('timer-countdown');
                    timerValueElement.style.animation = "";

                    // Show original timer value
                    fetch('/relay/status')
                        .then(response => response.json())
                        .then(data => {
                            if (data.TimerDuration) {
                                timerVal = parseInt(data.TimerDuration);
                                timerValueElement.textContent = timerVal;
                            } else {
                                timerValueElement.textContent = "0";
                            }
                        })
                        .catch(error => {
                            console.error("Error fetching relay status:", error);
                            timerValueElement.textContent = "0";
                        });

                    // Update UI state (will be fully updated when Firebase sends the update)
                    btnTimer.classList.remove('timer-active');

                    // Update status text (remove timer part)
                    if (relayStatusElement.textContent.includes(' | Timer:')) {
                        relayStatusElement.textContent = relayStatusElement.textContent.replace(/ \| Timer:.*/, '');
                    }

                    // Show toast notification
                    showToast("Timer completed!");
                }
            }, 1000);
        }

        // Helper function to show toast notifications
        function showToast(message, type = 'info') {
            // Create toast container if it doesn't exist
            let toastContainer = document.getElementById('toast-container');
            if (!toastContainer) {
                toastContainer = document.createElement('div');
                toastContainer.id = 'toast-container';
                toastContainer.style.position = 'fixed';
                toastContainer.style.bottom = '20px';
                toastContainer.style.right = '20px';
                toastContainer.style.zIndex = '9999';
                document.body.appendChild(toastContainer);
            }

            // Create toast element
            const toast = document.createElement('div');
            toast.style.padding = '10px 20px';
            toast.style.margin = '10px';
            toast.style.backgroundColor = type === 'error' ? '#f44336' : '#4CAF50';
            toast.style.color = 'white';
            toast.style.borderRadius = '5px';
            toast.style.boxShadow = '0 2px 10px rgba(0,0,0,0.3)';
            toast.style.opacity = '0';
            toast.style.transition = 'opacity 0.3s ease';
            toast.innerText = message;

            // Add to container
            toastContainer.appendChild(toast);

            // Fade in
            setTimeout(() => {
                toast.style.opacity = '1';
            }, 10);

            // Remove after 3 seconds
            setTimeout(() => {
                toast.style.opacity = '0';
                setTimeout(() => {
                    toast.remove();
                }, 300);
            }, 3000);
        }

        // Enhanced sensor data display with special handling for soil and water values
        function updateLiveSensorDisplays(data) {
            // Helper function to update with animation
            function updateWithAnimation(elementId, value, unit = '') {
                const element = document.getElementById(elementId);
                if (!element) return;

                const oldValue = element.textContent.replace(/[^0-9.]/g, '');

                if (parseFloat(oldValue) !== parseFloat(value)) {
                    element.textContent = value + unit;
                    element.parentElement.classList.remove('value-changed');
                    // Trigger reflow to restart animation
                    void element.parentElement.offsetWidth;
                    element.parentElement.classList.add('value-changed');
                }
            }

            // Update temperature and humidity normally
            if (data.Temperature !== undefined) {
                updateWithAnimation('live-temp', data.Temperature, '¬∞C');
            }

            if (data.Humidity !== undefined) {
                updateWithAnimation('live-humidity', data.Humidity, '%');
            }

            // Special handling for Soil moisture - display "DRY" or "WET" based on value
            if (data.Soil !== undefined) {
                if (data.Soil === "1" || data.Soil === 1) {
                    liveSoilElement.innerHTML = "<span class='dry'>DRY</span>";

                    // Note: Automatic activation is now handled server-side
                    // Just update UI to match the current state
                } else if (data.Soil === "0" || data.Soil === 0) {
                    liveSoilElement.innerHTML = "<span class='wet'>WET</span>";

                    // Note: Automatic deactivation is now handled server-side
                    // Just update UI to match the current state
                } else {
                    // For any other value, show as percentage
                    updateWithAnimation('live-soil', data.Soil, '%');
                }
            }

            // Special handling for Water level - convert to percentage using formula
            if (data.Water !== undefined) {
                const waterValue = parseFloat(data.Water);
                if (!isNaN(waterValue)) {
                    const waterPercentage = Math.floor(waterValue / 10);
                    updateWithAnimation('live-water', waterPercentage, '%');
                }
            }

            // Update the timestamp
            const now = new Date();
            const timeString = now.toLocaleTimeString();
            document.getElementById('last-update-time').textContent = 'Last updated: ' + timeString;
        }

        // Function to update relay state in Firebase
        function updateRelayFirebase(key, value) {
            let endpoint = key.toLowerCase();

            // Special handling for Timer which needs data in request body
            if (endpoint === 'timer') {
                // Send both the timer state and the seconds value
                fetch(`/relay/timer`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({ timer: value, seconds: timerVal })
                })
                    .then(response => response.json())
                    .then(data => {
                        console.log(`Timer set to ${value}:`, data);

                        if (value === "1") {
                            // Timer activated - UI will be updated when Firebase sends update
                            showToast(`Timer set for ${timerVal} seconds`);
                        } else {
                            // Timer stopped - UI will be updated when Firebase sends update
                            showToast("Timer stopped");
                        }
                    })
                    .catch(error => {
                        console.error(`Error setting timer:`, error);
                        showToast("Error setting timer", "error");
                    });
            } else {
                // For Automatic and Manual
                fetch(`/relay/${endpoint}`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({})
                })
                    .then(response => response.json())
                    .then(data => {
                        console.log(`Updated ${key} to ${value}:`, data);
                        if (key === "Automatic" && value === "1") {
                            showToast("Automatic mode activated");
                        } else if (key === "Manual" && value === "1") {
                            showToast("Manual mode activated");
                        }
                    })
                    .catch(error => {
                        console.error(`Error updating ${key}:`, error);
                        showToast(`Error updating ${key}`, "error");
                    });
            }
        }

        // ---- Override Event Listeners ----

        // Remove any existing event listeners and add our new ones
        function setupRelayEventListeners() {
            // Automatic button click handler
            btnAutomatic.onclick = function (e) {
                e.preventDefault();
                e.stopPropagation();

                btnAutomatic.disabled = true;
                btnAutomatic.textContent = 'Setting...';

                // If already active, turn it off, otherwise turn it on
                const newValue = btnAutomatic.classList.contains('active-mode') ? "0" : "1";

                // Send the explicit value in the request
                fetch(`/relay/automatic`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({ value: newValue })
                })
                    .then(response => response.json())
                    .then(data => {
                        console.log(`Updated Automatic to ${newValue}:`, data);
                        if (newValue === "1") {
                            showToast("Automatic mode activated");
                        } else {
                            showToast("Automatic mode and timer deactivated");
                        }
                    })
                    .catch(error => {
                        console.error(`Error updating Automatic:`, error);
                        showToast(`Error updating Automatic mode`, "error");
                    })
                    .finally(() => {
                        // Visual feedback (actual state will be updated when Firebase sends back update)
                        setTimeout(() => {
                            btnAutomatic.disabled = false;
                            btnAutomatic.textContent = 'Automatic';
                        }, 500);
                    });
            };

            // Manual button click handler - TOGGLE BEHAVIOR
            btnManual.onclick = function (e) {
                e.preventDefault();
                e.stopPropagation();

                btnManual.disabled = true;
                btnManual.textContent = 'Setting...';

                // Toggle behavior - simply send request to toggle manual state
                fetch(`/relay/manual`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({})
                })
                    .then(response => response.json())
                    .then(data => {
                        console.log("Manual toggle response:", data);
                        if (data.state === "1") {
                            showToast("Manual mode turned ON");
                        } else {
                            showToast("Manual mode turned OFF");
                        }
                    })
                    .catch(error => {
                        console.error("Error toggling manual mode:", error);
                        showToast("Error toggling manual mode", "error");
                    })
                    .finally(() => {
                        // Visual feedback (actual state will be updated when Firebase sends back update)
                        setTimeout(() => {
                            btnManual.disabled = false;
                            btnManual.textContent = 'Manual';
                        }, 500);
                    });
            };

            // Timer control: increase with validation
            timerPlus.onclick = function (e) {
                e.preventDefault();
                timerVal++;

                // Limit maximum timer duration (e.g., 1 hour = 3600 seconds)
                if (timerVal > 3600) {
                    timerVal = 3600;
                    showToast("Maximum timer duration is 1 hour", "info");
                }

                timerValueElement.textContent = timerVal;
            };

            // Timer control: decrease with validation
            timerMinus.onclick = function (e) {
                e.preventDefault();
                if (timerVal > 0) {
                    timerVal--;
                    timerValueElement.textContent = timerVal;
                }
            };

            // Timer set button with validation
            btnTimer.onclick = function (e) {
                e.preventDefault();

                // Validate timer value
                if (timerVal <= 0) {
                    showToast("Please set a timer value greater than 0", "error");
                    return;
                }

                btnTimer.disabled = true;
                btnTimer.textContent = 'Setting...';

                // Check if timer is already active
                if (btnTimer.classList.contains('timer-active')) {
                    // Stop the timer - this will also set Automatic to 0 on the server
                    updateRelayFirebase("Timer", "0");
                    showToast("Timer and automatic mode stopped");
                } else {
                    // Start the timer - this will also set Automatic to 1 on the server
                    updateRelayFirebase("Timer", "1");
                    showToast("Timer started and automatic mode activated");
                }

                // Visual feedback (actual state will be updated when Firebase sends back update)
                setTimeout(() => {
                    btnTimer.disabled = false;
                    btnTimer.textContent = 'Set Timer';
                }, 500);
            };

            console.log("Relay event listeners configured");
        }

        // ---- Firebase Real-time Updates ----

        // Enhanced SSE handling for real-time updates
        function setupEnhancedRealtimeUpdates() {
            // Check if EventSource is supported
            if (typeof EventSource !== 'undefined') {
                // Connect to the Firebase updates stream
                const firebaseUpdates = new EventSource('/firebase-updates');

                firebaseUpdates.onmessage = function (event) {
                    try {
                        const message = JSON.parse(event.data);
                        console.log("Firebase update received:", message);

                        if (message.type === 'sensor_update' || message.type === 'initial') {
                            // Process sensor data updates
                            updateLiveSensorDisplays(message.data);

                            // When we get a new sensor update, refresh the history
                            if (typeof loadSensorHistory === 'function') loadSensorHistory();
                            if (typeof refreshSensorChart === 'function') refreshSensorChart();
                        } else if (message.type === 'disease') {
                            // Handle disease updates
                            if (typeof updateDiseaseInfo === 'function') updateDiseaseInfo(message.data.disease);
                        } else if (message.type === 'relay_update') {
                            // Handle relay state updates
                            updateRelayButtonStates(message.data);
                        } else if (message.type === 'timer_expired') {
                            // Handle timer expiration (additional notification)
                            showToast("Timer completed!");
                        } else if (message.type === 'control_action') {
                            // Handle automatic control actions
                            if (message.data.action === 'automatic_on') {
                                showToast(`Automatic mode activated: ${message.data.reason}`);
                            } else if (message.data.action === 'automatic_off') {
                                showToast(`Automatic mode deactivated: ${message.data.reason}`);
                            }
                        }
                    } catch (error) {
                        console.error("Error processing Firebase update:", error);
                    }
                };

                firebaseUpdates.onerror = function (event) {
                    console.error("Firebase updates connection failed, reconnecting...", event);
                    firebaseUpdates.close();
                    setTimeout(setupEnhancedRealtimeUpdates, 5000);
                };
            } else {
                console.warn("Your browser doesn't support server-sent events. Falling back to polling.");
                // Fallback to polling (every 3 seconds)
                setInterval(function () {
                    fetch('/relay/status')
                        .then(response => response.json())
                        .then(data => {
                            updateRelayButtonStates(data);
                        })
                        .catch(error => {
                            console.error('Error fetching relay status:', error);
                        });

                    fetch('/sensor/current')
                        .then(response => response.json())
                        .then(data => {
                            updateLiveSensorDisplays(data);
                        })
                        .catch(error => {
                            console.error('Error fetching sensor data:', error);
                        });
                }, 3000);
            }
        }

        // ---- Initialize Firebase Integration ----

        // Function to initialize our Firebase integration
        function initFirebaseIntegration() {
            console.log("Initializing enhanced Firebase irrigation control integration...");

            // Override event listeners with our Firebase-connected ones
            setupRelayEventListeners();

            // Set up real-time updates
            setupEnhancedRealtimeUpdates();

            // Initial fetch of relay state
            fetch('/relay/status')
                .then(response => response.json())
                .then(data => {
                    console.log("Initial relay status:", data);
                    updateRelayButtonStates(data);

                    // Also store initial timer value if available
                    if (data.TimerDuration) {
                        timerVal = parseInt(data.TimerDuration);
                        timerValueElement.textContent = timerVal;
                    }
                })
                .catch(error => {
                    console.error('Error fetching initial relay status:', error);
                });

            // Initial fetch of sensor data
            fetch('/sensor/current')
                .then(response => response.json())
                .then(data => {
                    console.log("Initial sensor data:", data);
                    updateLiveSensorDisplays(data);
                })
                .catch(error => {
                    console.error('Error fetching initial sensor data:', error);
                });

            console.log("Firebase irrigation control integration initialized successfully");
        }

        // Initialize when the DOM is fully loaded
        document.addEventListener('DOMContentLoaded', initFirebaseIntegration);
    </script>

    <!-- Add these CSS styles to your existing styles -->
    <style>
        /* Improved timer countdown animation */
        @keyframes timer-countdown {
            0% {
                opacity: 1;
                color: white;
            }

            50% {
                opacity: 0.7;
                color: #ff6b6b;
            }

            100% {
                opacity: 1;
                color: white;
            }
        }

        /* Toast notification container */
        #toast-container {
            position: fixed;
            bottom: 20px;
            right: 20px;
            z-index: 9999;
        }
    </style>

    <!-- Add these CSS styles to your existing styles -->
    <style>
        /* Improved timer countdown animation */
        @keyframes timer-countdown {
            0% {
                opacity: 1;
                color: white;
            }

            50% {
                opacity: 0.7;
                color: #ff6b6b;
            }

            100% {
                opacity: 1;
                color: white;
            }
        }

        /* Toast notification container */
        #toast-container {
            position: fixed;
            bottom: 20px;
            right: 20px;
            z-index: 9999;
        }
    </style>
</body>

</html>